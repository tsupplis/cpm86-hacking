;     The contents of this file are subject to the Mozilla Public License
;     Version 1.0 (the "License"); you may not use this file except in
;     compliance with the License. You may obtain a copy of the License at
;     http://www.mozilla.org/MPL/
;
;     Software distributed under the License is distributed on an "AS IS"
;     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
;     License for the specific language governing rights and limitations
;     under the License.

quit:           
            xor     cx,cx 
            int     0E0h    
            ret
 
clear_keys:
            push    ax
            push    cx
            push    dx
            mov     dx,0FFh
            mov     cx,06h
            int     0E0h
            or      al, 0
            jnz     clear_keys
            pop     dx
            pop     cx
            pop     ax
            ret
                 
in_key:
            push    cx
            push    dx
            mov     dx,0FFh
            mov     cx,06h
            int     0E0h
            pop     dx
            pop     cx
            ret 

wait_key:
            push    cx
            push    bx
            push    dx
            push    di
            mov     bx, 01h  
wait_key_l2: 
            mov     di, 0FFFh  
wait_key_l1: 
            push    di
            push    bx
            mov     dx,0FFh
            mov     cx,06h
            int     0E0h
            pop     bx
            pop     di
            or      ax, 0
            jnz     wait_end
            dec     di   
            jnz     wait_key_l1    
            dec     bx 
            jnz     wait_key_l2 
wait_end:
            pop     di
            pop     dx
            pop     bx
            pop     cx
            ret                

delay:
            push    bx
            push    di
            mov     bx, 05h  
delay_l2: 
            mov     di, 0FFFFh  
delay_l1: 
            dec     di   
            jnz     delay_l1    
            dec     bx 
            jnz     delay_l2 
            pop     di
            pop     bx
            ret                

print_char:
            push	ax
            push	cx
            push	dx
            push	bx
            push    es
            xor     ah, ah
            mov     dx, ax
            mov     cl, 2            
            int     0E0h    
            pop	    es
            pop	    bx
            pop	    dx
            pop	    cx
            pop	    ax
            ret
print_uint16:
            push	ax
            push	cx
            push	dx
            push	bx
            push    es
            xor	    cx, cx
print_uint16_next1:
            xor	    dx, dx
            div 	bx
            cmp	    dl, 10
            jb	    print_uint16_isdigit
            add	    dl, 'A' - 10 - '0';
print_uint16_isdigit:
            add	    dl, '0'
            push	dx
            inc	    cx
            or	    ax, ax
            jnz	    print_uint16_next1
print_uint16_next2:
            pop	    ax
            push    cx
            push    dx
            mov	    dx, ax
            xor     dh,dh
            mov	    cx, 02h
            int	    0E0h
            pop     dx
            pop     cx
            loop	print_uint16_next2
            pop     es
            pop	    bx
            pop	    dx
            pop	    cx
            pop	    ax
            ret
print_str:
            push	ax
            push	bx
            push    cx
            push    dx
            push	es
            push	si
            cld
print_str_next:
            lodsb
            or	    al, al
            jz	    print_str_done
            mov	    dx, ax
            xor     dh, dh
            mov	    cx, 02h
            int	    0E0h
            jmp	    print_str_next
print_str_done:
            pop	    si
            pop     es
            pop     dx
            pop     cx
            pop	    bx
            pop	    ax
            ret                

to_lower:   
            cmp     al, '^'
            jne     to_lower_cnt
            or      bh, bh
            jz      to_lower_on
            xor     bh, bh
            jmp     to_lower_end
to_lower_on:
            mov     bh, 1
            jmp     to_lower_end
to_lower_cnt:
            or      bh,  bh
            jz      to_lower_end
            cmp     al, 'A'
            jb      to_lower_end
            cmp     al, 'Z'
            ja      to_lower_end
            add     al, 32
to_lower_end:
            ret

print_dec4:
         mov	    dx, 4
         jmp	    print_dec

print_dec2:
    	mov	    dx, 2
        xor	    ah, ah
print_dec:
         push	dx
         mov	    dx, 10
         push	dx
         push	ax
         call	print_uint16
         add	    sp, 6
         ret

check_286_plus:
        push    ax
        pushf
        ; ==========================================
        ; === CHECK #1 =============================
        ; ==========================================
        ; Sets FLAGS to 0x0 and then immediately reads it back. On an 8086/80186, bits
        ; 12-15 always come back set. On a 80286+ this is not the case.
        ; 8086/80186 behavior: clc
        ; 80286+ behavior: stc
        xor ax,ax      ; AX=0x0
        push ax
        popf          ; pop 0x0 into FLAGS
        pushf
        pop ax         ; pop FLAGS into AX

        and ax,0F000h  ; bits 12-13: IOPL, always 1 on 86/186
        cmp ax,0F000h  ; bit 14: NT, always 1 on 86/186
                       ; bit 15: Reserved, always 1 on 86/186, always 0 on 286+
        jz check_186_minus
        popf
        stc
        pop ax
        ret
check_186_minus:
        popf
        clc
        pop ax
        ret



     
